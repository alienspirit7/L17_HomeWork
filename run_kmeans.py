#!/usr/bin/env python3
"""Run K-Means clustering over normalized title embeddings and generate reports."""
from __future__ import annotations

import argparse
import json
import logging
import sys
from pathlib import Path
from typing import Any, Dict, Optional

import numpy as np
from sklearn.cluster import KMeans

from utils.data_io import load_dataset, dataframe_to_matrix
from utils.clustering import build_metrics, save_record_level, save_report, save_centroids


def parse_args(argv: Optional[list] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Run K-Means clustering (k=3) on normalized embeddings.")
    parser.add_argument("--data", required=True, help="Path to dataset produced by prepare_embeddings.py.")
    parser.add_argument("--seed", type=int, default=42, help="Random seed for reproducibility.")
    parser.add_argument("--output", help="Optional path to write detailed record-level clustering results.")
    parser.add_argument("--report", help="Optional path to write aggregate clustering report (CSV or Markdown).")
    parser.add_argument("--manifest", help="Optional path to manifest JSON generated by prepare_embeddings.py.")
    parser.add_argument("--centroids", help="Optional path to persist cluster centroids as JSON.")
    parser.add_argument(
        "--log-level", default="info", choices=["debug", "info", "warning", "error", "critical"],
        help="Logging verbosity."
    )
    return parser.parse_args(argv)


def configure_logging(level: str) -> None:
    logging.basicConfig(level=getattr(logging, level.upper()), format="%(asctime)s %(levelname)s %(message)s")


def load_manifest(dataset_path: Path, manifest_override: Optional[Path]) -> Optional[Dict[str, Any]]:
    """Load manifest JSON file.

    Args:
        dataset_path: Path to dataset file
        manifest_override: Optional explicit manifest path

    Returns:
        Manifest dictionary or None
    """
    candidate_paths = [manifest_override] if manifest_override else [dataset_path.with_suffix(".manifest.json")]
    for candidate in candidate_paths:
        if candidate.exists():
            try:
                return json.loads(candidate.read_text(encoding="utf-8"))
            except json.JSONDecodeError as exc:
                logging.warning("Failed to parse manifest %s: %s", candidate, exc)
    return None


def main(argv: Optional[list] = None) -> None:
    args = parse_args(argv)
    configure_logging(args.log_level)

    data_path = Path(args.data)
    manifest_path = Path(args.manifest) if args.manifest else None
    if not data_path.exists():
        raise FileNotFoundError(f"Dataset not found: {data_path}")

    df = load_dataset(data_path, required_cols={"title", "original_group", "normalized_embedding"})
    normalized = dataframe_to_matrix(df, "normalized_embedding")
    titles = df["title"].tolist()
    logging.info("Loaded %d vectors of dimension %d", normalized.shape[0], normalized.shape[1])

    # K-Means with k=3 (hardcoded as per PRD)
    k = 3
    kmeans = KMeans(n_clusters=k, random_state=args.seed, n_init="auto")
    assignments = kmeans.fit_predict(normalized)
    centroids = kmeans.cluster_centers_
    distances = np.linalg.norm(normalized - centroids[assignments], axis=1)

    metrics = build_metrics(df, assignments, kmeans)

    logging.info("K-Means complete: inertia=%.4f mismatch_rate=%.4f", metrics.inertia, metrics.mismatch_rate)
    if metrics.silhouette is not None:
        logging.info("Silhouette (cosine)=%.4f", metrics.silhouette)

    if args.output:
        save_record_level(df, assignments, distances, Path(args.output))

    if args.report:
        save_report(metrics, Path(args.report))

    manifest = load_manifest(data_path, manifest_path)
    if args.centroids:
        save_centroids(Path(args.centroids), kmeans, manifest)

    logging.info("Cluster sizes: %s", metrics.cluster_sizes)
    logging.info("Majority group mapping: %s", metrics.majority_mapping)


if __name__ == "__main__":
    try:
        main()
    except Exception as exc:
        logging.error("Failed: %s", exc)
        sys.exit(1)
